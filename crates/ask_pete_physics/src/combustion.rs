use bevy::prelude::*;
use pete_core::locomotive::{CargoHold, FuelTank, LocomotiveStats, MentalState};

// --- Physics Constants ---
const GRAVITY: f32 = 9.81;
const ROLLING_RESISTANCE: f32 = 0.01; // Steel on Steel
const _STATIC_FRICTION: f32 = 0.1; // Breakaway force

// --- Components ---

#[derive(Component)]
pub struct TrackGradient {
    pub grade_percent: f32, // e.g., 0.03 for 3%
    pub static_noise: f32,  // Environmental distraction (0.0 - 1.0)
}

impl Default for TrackGradient {
    fn default() -> Self {
        Self {
            grade_percent: 0.0,
            static_noise: 0.0,
        }
    }
}

// --- Systems ---

pub fn combustion_system(
    mut query: Query<(
        &LocomotiveStats,
        &mut FuelTank,
        &CargoHold,
        &mut MentalState,
        &mut Transform, // Using Transform as proxy for Velocity for now
        &TrackGradient,
    )>,
    time: Res<Time>,
) {
    for (stats, mut fuel, cargo, mut mental_state, mut transform, track) in query.iter_mut() {
        // 1. Calculate Mass (Chassis + Cargo)
        // Assuming Chassis Mass is implicit in Traction/Archetype, but let's say base is 100 Tons
        let chassis_mass = 100.0;
        let cargo_mass: f32 = cargo.items.iter().map(|i| i.intrinsic_weight).sum();
        let total_mass = chassis_mass + cargo_mass;

        // 2. Calculate Resistance Forces
        // F_gravity = Mass * g * sin(theta) ~ Mass * g * grade
        let f_gravity = total_mass * GRAVITY * track.grade_percent;

        // F_rolling = Mass * g * C_rr
        let f_rolling = total_mass * GRAVITY * ROLLING_RESISTANCE;

        // F_static = Mass * StaticNoise (Distraction Drag)
        let f_static = total_mass * track.static_noise;

        let total_resistance = f_gravity + f_rolling + f_static;

        // 3. Calculate Power Required
        // Power = Force * Velocity. Let's assume target velocity is stats.velocity
        let target_velocity = stats.velocity;
        let power_required = total_resistance * target_velocity;

        // 4. Calculate Burn Rate (Coal -> Steam)
        // Efficiency reduces coal cost. Scale increases it.
        let scale_penalty = 1.0 + mental_state.scale_level;
        let effective_efficiency = stats.efficiency / scale_penalty;

        // Burn = Power / Efficiency
        let coal_burn = (power_required / effective_efficiency) * time.delta_seconds();

        // 5. Apply Thermodynamics
        if fuel.coal >= coal_burn {
            fuel.coal -= coal_burn;

            // Generate Steam (Work Done)
            // Steam is generated by heat.
            // Simplified: Steam = Coal Burned * Efficiency
            let steam_generated = coal_burn * effective_efficiency;
            fuel.steam = (fuel.steam + steam_generated).min(fuel.max_steam);

            // Consume Steam to Move
            // Work = Power * Time
            let work_done = power_required * time.delta_seconds();
            if fuel.steam >= work_done {
                fuel.steam -= work_done;
                // Move the train (Simulation)
                transform.translation.x += target_velocity * time.delta_seconds();
                mental_state.is_stalled = false;
            } else {
                // Not enough steam pressure!
                mental_state.is_stalled = true;
            }
        } else {
            // Out of Coal!
            fuel.coal = 0.0;
            mental_state.is_stalled = true;
            // Panic check?
        }
    }
}
